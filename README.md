I, @adMartem, am a programmer. Started out with Fortran and SPS for the IBM 1620.  Got a job in the Analog/Digital Hybrid Computing lab at the University of Texas at Austin and started writing assembly language stuff for the SDS 930.  Morphed into a systems programmer initially writing parts of an in-house developed real-time OS for the 930 called "Spider".  At that point, I decided I liked "systems programming". 

The SDS Real-Time Fortran IV compiler for the machine was too slow (100 lines/minute) and buggy, so (by that time manager of 3 other programmers at the lab) I worked on a from-scratch Fortran compiler for Spider. It ran at 5,000 l/m.  We got a new ID/4 analog computer to attach to the 930, so we became the Hybrid Computing Lab. Along the way, I designed some hardware mods for the 930 to make it more secure in a multiprogrammed real-time environment, which were eventually picked up by Martin Kellogg at Los Alamos (not sure if they actually used them, however). When we got a new Sigma 5 digital machine, I began writing a new improved versaion of Spider for it.  But when the 930 drum crashed and we couldn't affort a replacement, I ended up making the Sigma 5 a disk controller for the 930.  After about 7 years at the lab while going to school, I went to work for Texas Instruments.

At TI, I was in the Advanced Scientific Computer operating system group. The ASC was a theoretically very fast general purpose vector-optimized machine TI developed for its Geophysical Services (oil exploration) company. It was also offered for sale to the scientific computing community as a competitor to the CDC offerings at the time.  While it was very fast when performing its scientific programs (written in a very highly vectorizing Fortran), its overall job throughput was abysmal. I initially worked in the integration group (about a half dozen of us) who took OS code produced by the "development" group, who coded things designed by the "design" group.  We ended up debugging and rewriting most of the code we received from development.  One night, right before a critical review by a government lab sales prospect, I decided I was tired of wondering if the machine was working on real work or OS overhead, so I programmed the main dispatcher to turn off one of the console lights when the CPU was not performing useful work. It turned out the light became my claim to fame. A week or so later, in the cafeteria line, I overheard one of the group managers telling another, "He was the one that implemented the CPU effiency indicator."  Word spread, apparently, and I was moved to the development group, but I continued to do my own "integration" while I worked on a project to improve the OS efficiency (i.e., make the light stay on more of the time). I used techniques developed for Spider and managed to move the throughput bottlenext out of the OS into somewhere else.  After a couple of years, I decided to move on, and ended up back at UT.  This time it was the main Computation Center.

More later...
<!---
adMartem/adMartem is a ✨ special ✨ repository because its `README.md` (this file) appears on your GitHub profile.
You can click the Preview link to take a look at your changes.
--->
